# Following code generated by ChatGPT o3.

from __future__ import annotations

"""
PerfectAIPlayer — a game‑theoretic optimal AI for the standard 4 × 4 Collapsi ruleset.

This implementation uses a memoised minimax/retrograde analysis on an efficient
bit‑encoded state representation:
    state  = (collapsed_mask, p0_idx, p1_idx, player_to_move)
where
    collapsed_mask  –  16‑bit int, bit i == 1 ⟺ card i is collapsed
    pX_idx          –  square index (row*size+col) of player X (always on a live card)
The static card *values* never change, so they are stored once per instance.

Depth ≤ 31 moves and a reachable state‑space under ~3 M makes a full search
practical (<1 s startup on modern hardware; subsequent queries are O(1)).
The AI *never* moves from a winning to a losing position.  If started in a
mathematically lost state it plays any legal move (delaying defeat as long
as possible).
"""

from typing import List, Optional, Tuple, Dict
from collapsi_core import Position, Game
from player_interface import Player


class PerfectAIPlayer(Player):
    """Deterministic, perfect‑play AI."""

    # ---- public API -----------------------------------------------------

    def __init__(self, player_id: int, name: str | None = None):
        super().__init__(player_id, name or f"Perfect AI {player_id + 1}")
        # lazily filled on first get_move call
        self._initialised = False
        self._size: int = 4
        self._values: Tuple[int, ...] = ()  # card numeric values, len == size*size
        self._nbrs: List[Tuple[int, int, int, int]] = []  # up, down, left, right indices for each cell
        self._cache: Dict[Tuple[int, int, int, int], Tuple[int, Optional[Tuple[int, ...]]]] = {}

    # ---- Player interface ----------------------------------------------

    def get_move(
        self,
        game: Game,
        valid_moves: List[List[Position]],
    ) -> Optional[List[Position]]:
        if not valid_moves:
            return None  # no legal move — shouldn’t be called in this case

        if not self._initialised:
            self._initialise_from_game(game)

        collapsed_mask, p0_idx, p1_idx = self._encode_board(game)
        current = game.current_player

        outcome, best = self._solve(collapsed_mask, p0_idx, p1_idx, current)

        # best can be None only if the position is already lost.
        if best is None:
            return valid_moves[0]

        return [self._idx_to_pos(i) for i in best]

    # ---- internal helpers ----------------------------------------------

    def _initialise_from_game(self, game: Game):
        self._size = game.board.size
        s = self._size

        # pre‑compute neighbours with wrap‑around
        self._nbrs = [()
                      for _ in range(s * s)]
        for r in range(s):
            for c in range(s):
                i = r * s + c
                up = ((r - 1) % s) * s + c
                dn = ((r + 1) % s) * s + c
                lf = r * s + ((c - 1) % s)
                rt = r * s + ((c + 1) % s)
                self._nbrs[i] = (up, dn, lf, rt)

        # static card values
        values: list[int] = []
        for r in range(s):
            for c in range(s):
                card = game.board.grid[r][c]
                values.append(card.value.value)
        self._values = tuple(values)

        self._initialised = True

    # --------------------------------------------------------------------

    def _encode_board(self, game: Game) -> Tuple[int, int, int]:
        """Return (collapsed_mask, p0_idx, p1_idx)."""
        mask = 0
        s = self._size
        for r in range(s):
            for c in range(s):
                if game.board.grid[r][c].is_collapsed:
                    mask |= 1 << (r * s + c)
        p0 = game.board.player_positions[0]
        p1 = game.board.player_positions[1]
        p0_idx = p0.row * s + p0.col
        p1_idx = p1.row * s + p1.col
        return mask, p0_idx, p1_idx

    # --------------------------------------------------------------------

    def _generate_moves(
        self,
        collapsed: int,
        start_idx: int,
        steps: int,
        opponent_idx: int,
    ) -> List[Tuple[int, ...]]:
        """Enumerate all legal paths of exact length *steps* starting at *start_idx*."""
        if steps == 0:
            return []

        res: List[Tuple[int, ...]] = []
        visited = collapsed | (1 << start_idx)  # mark start as visited
        path: List[int] = []

        def dfs(cur: int, left: int, vis: int):
            if left == 0:
                if cur != start_idx:
                    res.append(tuple(path))
                return
            for nxt in self._nbrs[cur]:
                if nxt == opponent_idx:
                    continue
                if vis & (1 << nxt):  # already visited or collapsed
                    continue
                path.append(nxt)
                dfs(nxt, left - 1, vis | (1 << nxt))
                path.pop()

        dfs(start_idx, steps, visited)
        return res

    # --------------------------------------------------------------------

    def _solve(
        self,
        collapsed: int,
        p0_idx: int,
        p1_idx: int,
        current: int,
    ) -> Tuple[int, Optional[Tuple[int, ...]]]:
        """Minimax with memoisation.

        Returns (value, best_path) where value ∈ {+1 (win), −1 (loss)} for the
        *current* player.  best_path is None iff value == −1.
        """
        key = (collapsed, p0_idx, p1_idx, current)
        if key in self._cache:
            return self._cache[key]

        start_idx = p0_idx if current == 0 else p1_idx
        opponent_idx = p1_idx if current == 0 else p0_idx
        steps = self._values[start_idx]

        moves = self._generate_moves(collapsed, start_idx, steps, opponent_idx)
        if not moves:  # no legal move => lose immediately
            result = (-1, None)
            self._cache[key] = result
            return result

        # try to find a winning move
        new_collapsed = collapsed | (1 << start_idx)
        for mv in moves:
            final_idx = mv[-1]
            if current == 0:
                child_val, _ = self._solve(new_collapsed, final_idx, p1_idx, 1)
            else:
                child_val, _ = self._solve(new_collapsed, p0_idx, final_idx, 0)
            if child_val == -1:  # opponent loses ⇒ we win
                result = (1, mv)
                self._cache[key] = result
                return result

        # all moves lead to opponent’s win ⇒ we lose; pick first to prolong
        result = (-1, moves[0])
        self._cache[key] = result
        return result

    # --------------------------------------------------------------------

    def _idx_to_pos(self, idx: int) -> Position:
        return Position(idx // self._size, idx % self._size)
